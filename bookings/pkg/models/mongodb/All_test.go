// ********RoostGPT********
/*
Test generated by RoostGPT for test go-with-application-test using AI Type Open AI and AI Model gpt-4o

ROOST_METHOD_HASH=All_4c4a1c9150
ROOST_METHOD_SIG_HASH=All_1b003a62af

The `All` function in the `bookings.go` file is implemented to fetch all records from the `bookings` MongoDB collection. Here's a simplified view of the function:

```go
func (m *BookingModel) All() ([]models.Booking, error) {
    // Define variables
	ctx := context.TODO()
	b := []models.Booking{}

	// Find all bookings
	bookingCursor, err := m.C.Find(ctx, bson.M{})
	if err != nil {
		return nil, err
	}
	err = bookingCursor.All(ctx, &b)
	if err != nil {
		return nil, err
	}

	return b, err
}
```

### Test Scenarios

#### Scenario 1: Successful fetch of all booking records

**Details:**
  * Description: This test checks if the `All` function correctly fetches all booking records when there are multiple records present in the collection.
**Execution:**
  * Arrange: Use a mock MongoDB collection with multiple booking records.
  * Act: Call the `All` function.
  * Assert: Verify the returned slice contains all the records and error is `nil`.
**Validation:**
  * Justify: This test ensures that the function correctly fetches all documents.
  * Importance: Core function of fetching all booking records needs to work correctly.
  
#### Scenario 2: No booking records present

**Details:**
  * Description: This test checks if the `All` function handles the scenario where there are no booking records in the collection.
**Execution:**
  * Arrange: Use a mock MongoDB collection with no booking records.
  * Act: Call the `All` function.
  * Assert: Verify the returned slice is empty and error is `nil`.
**Validation:**
  * Justify: This test confirms that the function gracefully handles the absence of records without errors.
  * Importance: Ensure proper behavior when collection is empty.

#### Scenario 3: MongoDB find operation error

**Details:**
  * Description: This test checks how the `All` function handles errors encountered during the MongoDB `Find` operation.
**Execution:**
  * Arrange: Use a mock MongoDB collection that returns an error on `Find`.
  * Act: Call the `All` function.
  * Assert: Verify the returned slice is `nil` and the error is correctly propagated.
**Validation:**
  * Justify: It's crucial to verify error propagation to diagnose backend issues.
  * Importance: Error handling is essential for robustness.

#### Scenario 4: MongoDB cursor `All` operation error

**Details:**
  * Description: This test checks how the `All` function handles errors encountered during iterating the cursor to fetch records.
**Execution:**
  * Arrange: Use a mock MongoDB collection and cursor that returns an error on `All`.
  * Act: Call the `All` function.
  * Assert: Verify the returned slice is `nil` and the error is correctly propagated.
**Validation:**
  * Justify: Similarly to the previous scenario, handling cursor-related errors is vital.
  * Importance: Ensuring that backend operations handle errors correctly enhances reliability.

### Example Test Implementation in Go

To implement the above scenarios in Go, you would typically use a testing library such as `testify` for assertions and `mongo-go-driver` with `mocks` for simulating MongoDB interactions.

Here is a high-level example test (the test package should be created in a new file, `bookings_test.go`):

```go
package mongodb

import (
	"context"
	"errors"
	"testing"

	"github.com/stretchr/testify/assert"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/integration/mtest"
	"microservices-docker-go-mongodb/bookings/pkg/models"
)

type MockCollection struct {
	m *mtest.T
}

func (mc *MockCollection) Find(ctx context.Context, filter interface{}, opts ...*options.FindOptions) (*mongo.Cursor, error) {
	// Based on scenario, implement mock behavior
}

func TestAll(t *testing.T) {
	mock, client := mtest.CreateClient(&mtest.Options{})
	defer mock.Close()

	mc := &MockCollection{m: mock}
	model := &BookingModel{C: mc}

	t.Run("Fetch All Bookings - Success", func(t *testing.T) {
		bookings := []models.Booking{
			{ID: "1", Name: "Test Booking 1"},
			{ID: "2", Name: "Test Booking 2"},
		}

		mock.AddMockResponses(mtest.CreateCursorResponse(1, "bookings.bookings", mtest.FirstBatch, bookings...))
		actual, err := model.All()

		assert.NoError(t, err)
		assert.Len(t, actual, len(bookings))
		assert.Equal(t, bookings, actual)
	})

	t.Run("No Bookings Present", func(t *testing.T) {
		// Add empty mock response
		mock.AddMockResponses(mtest.CreateCursorResponse(0, "bookings.bookings", mtest.FirstBatch))
		actual, err := model.All()

		assert.NoError(t, err)
		assert.Len(t, actual, 0)
	})

	t.Run("MongoDB Find Error", func(t *testing.T) {
		mock.AddMockResponses(mtest.CreateCommandErrorResponse(mtest.CommandError{
			Code:    11000,
			Message: "Find error",
		}))
		actual, err := model.All()

		assert.Error(t, err)
		assert.Nil(t, actual)
	})

	t.Run("Cursor All Error", func(t *testing.T) {
		// Simulating cursor error, this generally requires more detailed mock setup
		mock.AddMockResponses(mtest.CreateCursorResponse(1, "bookings.bookings", mtest.FirstBatch), mtest.CreateErrorResponse(mtest.CommandError{
			Code:    11001,
			Message: "Cursor all error",
		}))
		actual, err := model.All()

		assert.Error(t, err)
		assert.Nil(t, actual)
	})
}
```

This snippet demonstrates how you would structure your tests for different scenarios around the `All` function in MongoDB collection operations. Make sure to adapt the `MockCollection` and other parts to fit your specific implementation and dependencies.
*/

// ********RoostGPT********
// bookings_test.go
package mongodb

import (
	"context"
	"errors"
	"testing"
	"microservices-docker-go-mongodb/bookings/pkg/models"

	"github.com/stretchr/testify/assert"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
	"go.mongodb.org/mongo-driver/mongo/integration/mtest"
)

type MockCollection struct {
	m *mtest.T
}

func (mc *MockCollection) Find(ctx context.Context, filter interface{}, opts ...*options.FindOptions) (*mongo.Cursor, error) {
	switch mc.m.GetID() {
	case "Fetch All Bookings - Success":
		return mtest.CreateCursorResponse(1, "bookings.bookings", mtest.FirstBatch, bookings...).(*mongo.Cursor), nil
	case "MongoDB Find Error":
		return nil, errors.New("Find error")
	default:
		return mtest.CreateCursorResponse(0, "bookings.bookings", mtest.FirstBatch).(*mongo.Cursor), nil
	}
}

func TestAll(t *testing.T) {
	mock, client := mtest.CreateClient(&mtest.Options{})
	defer mock.Close()

	bookingModel = &BookingModel{C: client.Database("mockdb").Collection("bookings")}

	testCases := []struct {
		name     string
		setup    func()
		validate func([]models.Booking, error)
	}{
		{
			name: "Fetch All Bookings - Success",
			setup: func() {
				bookings := []models.Booking{
					{ID: "1", Name: "Test Booking 1"},
					{ID: "2", Name: "Test Booking 2"},
				}
				mock.AddMockResponses(mtest.CreateCursorResponse(1, "bookings.bookings", mtest.FirstBatch, bookings...))
			},
			validate: func(actual []models.Booking, err error) {
				bookings := []models.Booking{
					{ID: "1", Name: "Test Booking 1"},
					{ID: "2", Name: "Test Booking 2"},
				}
				assert.NoError(t, err)
				assert.Len(t, actual, len(bookings))
				assert.Equal(t, bookings, actual)
			},
		},
		{
			name: "No Bookings Present",
			setup: func() {
				mock.AddMockResponses(mtest.CreateCursorResponse(0, "bookings.bookings", mtest.FirstBatch))
			},
			validate: func(actual []models.Booking, err error) {
				assert.NoError(t, err)
				assert.Len(t, actual, 0)
			},
		},
		{
			name: "MongoDB Find Error",
			setup: func() {
				mock.AddMockResponses(mtest.CreateCommandErrorResponse(mtest.CommandError{
					Code:    11000,
					Message: "Find error",
				}))
			},
			validate: func(actual []models.Booking, err error) {
				assert.Error(t, err)
				assert.Nil(t, actual)
			},
		},
		{
			name: "Cursor All Error",
			setup: func() {
				mock.AddMockResponses(mtest.CreateCursorResponse(1, "bookings.bookings", mtest.FirstBatch), mtest.CreateCommandErrorResponse(mtest.CommandError{
					Code:    11001,
					Message: "Cursor all error",
				}))
			},
			validate: func(actual []models.Booking, err error) {
				assert.Error(t, err)
				assert.Nil(t, actual)
			},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			tc.setup()
			actual, err := bookingModel.All()
			tc.validate(actual, err)
		})
	}
}

