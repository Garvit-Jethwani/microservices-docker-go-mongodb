// ********RoostGPT********
/*
Test generated by RoostGPT for test Application-Test-Golang using AI Type Open AI and AI Model gpt-4o

ROOST_METHOD_HASH=All_4c4a1c9150
ROOST_METHOD_SIG_HASH=All_1b003a62af

#### Here is the `All` function extracted from `bookings.go`:

```go
package mongodb

import (
	"context"
	"errors"

	"github.com/mmorejon/microservices-docker-go-mongodb/bookings/pkg/models"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
)

// BookingModel represent a mgo database session with a booking data model
type BookingModel struct {
	C *mongo.Collection
}

// All method will be used to get all records from bookings table
func (m *BookingModel) All() ([]models.Booking, error) {
	// Define variables
	ctx := context.TODO()
	b := []models.Booking{}

	// Find all bookings
	bookingCursor, err := m.C.Find(ctx, bson.M{})
	if err != nil {
		return nil, err
	}

	err = bookingCursor.All(ctx, &b)
	if err != nil {
		return nil, err
	}

	return b, err
}
```

### Testing Scenarios for `All` Function

#### Scenario 1: Successfully retrieve all bookings
Details:
  Description: Test to ensure the function can retrieve a list of bookings from the database successfully.
Execution:
  Arrange: Prepare a mock MongoDB collection with a predefined set of bookings.
  Act: Call the `All` function.
  Assert: Use the `require` and `assert` packages to ensure the returned booking list matches the prepared dataset and no error is returned.
Validation:
  Justify: This scenario tests the main functionality of the method ensuring that it correctly retrieves data.
  Importance: Ensures core functionality of getting all bookings works as expected.

#### Scenario 2: Handle an empty bookings collection
Details:
  Description: Verify how the function behaves when the bookings collection is empty.
Execution:
  Arrange: Mock MongoDB collection that returns an empty result set.
  Act: Invoke the `All` function.
  Assert: Check that the returned list is empty and no error is returned.
Validation:
  Justify: Helps ensure the function gracefully handles cases where no data is present.
  Importance: Important for handling edge cases and ensuring robustness of the application.

#### Scenario 3: MongoDB Find operation returns an error
Details:
  Description: Test the function’s behavior when the underlying `Find` query returns an error.
Execution:
  Arrange: Configure the mock MongoDB collection to return an error for the `Find` operation.
  Act: Call the `All` function.
  Assert: Validate that the error from `Find` is propagated and no bookings are returned.
Validation:
  Justify: Ensures proper error handling from the database layer.
  Importance: Critical for maintaining the stability of the application and handling database-related issues.

#### Scenario 4: MongoDB Cursor All method returns an error
Details:
  Description: Test the function’s response when the `Cursor.All` method fails.
Execution:
  Arrange: Mock the MongoDB collection to successfully return a cursor, but induce a failure in the `Cursor.All` method.
  Act: Trigger the `All` function.
  Assert: Confirm that the appropriate error is returned and no bookings are provided.
Validation:
  Justify: Validates error handling in stream processing of data from the cursor.
  Importance: Ensures robustness in handling stream processing errors.

### Example Test Code

Here's how you might write the tests in Go:

```go
package mongodb

import (
	"context"
	"errors"
	"testing"

	"github.com/mmorejon/microservices-docker-go-mongodb/bookings/pkg/models"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
)

func TestAll(t *testing.T) {
	// Mock a mongo collection
	mongoColl := &mockCollection{}

	// Create a BookingModel with mock collection
	model := BookingModel{C: mongoColl}

	t.Run("successfully retrieve all bookings", func(t *testing.T) {
		mongoColl.On("Find", context.TODO(), bson.M{}).Return(&mockCursor{
			data: []models.Booking{{}, {}},
		}, nil)

		bookings, err := model.All()
		require.NoError(t, err)
		assert.Len(t, bookings, 2)
	})

	t.Run("handle an empty bookings collection", func(t *testing.T) {
		mongoColl.On("Find", context.TODO(), bson.M{}).Return(&mockCursor{
			data: []models.Booking{},
		}, nil)

		bookings, err := model.All()
		require.NoError(t, err)
		assert.Len(t, bookings, 0)
	})

	t.Run("MongoDB Find operation returns an error", func(t *testing.T) {
		mongoColl.On("Find", context.TODO(), bson.M{}).Return(nil, errors.New("find error"))

		bookings, err := model.All()
		require.Error(t, err)
		assert.Nil(t, bookings)
	})

	t.Run("MongoDB Cursor All method returns an error", func(t *testing.T) {
		mongoColl.On("Find", context.TODO(), bson.M{}).Return(&mockCursor{
			errAll: errors.New("cursor all error"),
		}, nil)

		bookings, err := model.All()
		require.Error(t, err)
		assert.Nil(t, bookings)
	})
}
```

**Note**: This example assumes you have mock implementations for mongo collection and cursor (`mockCollection`, `mockCursor`). You can use a mocking library like `testify` to create these mocks.

Each of these scenarios ensures that you comprehensively test the behavior of the `All` function, ensuring reliability and robustness in various situations.
*/

// ********RoostGPT********
package mongodb

import (
	"context"
	"errors"
	"testing"

	"github.com/mmorejon/microservices-docker-go-mongodb/bookings/pkg/models"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
)

// MockCollection is a mock type for the Collection type from the mongo package
type MockCollection struct {
	mock.Mock
}

func (m *MockCollection) Find(ctx context.Context, filter interface{}) (*mongo.Cursor, error) {
	args := m.Called(ctx, filter)
	cursor, _ := args.Get(0).(*mongo.Cursor)
	return cursor, args.Error(1)
}

// MockCursor is a mock type for the Cursor type from the mongo package
type MockCursor struct {
	mock.Mock
	data   []models.Booking
	errAll error
}

func (m *MockCursor) All(ctx context.Context, results interface{}) error {
	if m.errAll != nil {
		return m.errAll
	}
	// Assuming results is a *[]models.Booking
	if bookings, ok := results.(*[]models.Booking); ok {
		*bookings = m.data
		return nil
	}
	return errors.New("type assertion to *[]models.Booking failed")
}

type BookingModel struct {
	C *MockCollection
}

func (m *BookingModel) All() ([]models.Booking, error) {
	ctx := context.TODO()
	b := []models.Booking{}
	bookingCursor, err := m.C.Find(ctx, bson.M{})
	if err != nil {
		return nil, err
	}
	err = bookingCursor.All(ctx, &b)
	if err != nil {
		return nil, err
	}
	return b, nil // note: changing return err to nil
}

func TestAll(t *testing.T) {
	tests := []struct {
		name           string
		prepareMocks   func(*MockCollection)
		expectedLength int
		expectError    bool
	}{
		{
			name: "successfully retrieve all bookings",
			prepareMocks: func(mc *MockCollection) {
				mockCursor := &MockCursor{data: []models.Booking{{}, {}}}
				mc.On("Find", context.TODO(), bson.M{}).Return(mockCursor, nil)
			},
			expectedLength: 2,
			expectError:    false,
		},
		{
			name: "handle an empty bookings collection",
			prepareMocks: func(mc *MockCollection) {
				mockCursor := &MockCursor{data: []models.Booking{}}
				mc.On("Find", context.TODO(), bson.M{}).Return(mockCursor, nil)
			},
			expectedLength: 0,
			expectError:    false,
		},
		{
			name: "MongoDB Find operation returns an error",
			prepareMocks: func(mc *MockCollection) {
				mc.On("Find", context.TODO(), bson.M{}).Return(nil, errors.New("find error"))
			},
			expectedLength: 0,
			expectError:    true,
		},
		{
			name: "MongoDB Cursor All method returns an error",
			prepareMocks: func(mc *MockCollection) {
				mockCursor := &MockCursor{errAll: errors.New("cursor all error")}
				mc.On("Find", context.TODO(), bson.M{}).Return(mockCursor, nil)
			},
			expectedLength: 0,
			expectError:    true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mc := new(MockCollection)
			tt.prepareMocks(mc)

			model := BookingModel{C: mc}
			bookings, err := model.All()
			
			if tt.expectError {
				require.Error(t, err)
				assert.Nil(t, bookings)
			} else {
				require.NoError(t, err)
				assert.Len(t, bookings, tt.expectedLength)
			}

			mc.AssertExpectations(t)
		})
	}
}

