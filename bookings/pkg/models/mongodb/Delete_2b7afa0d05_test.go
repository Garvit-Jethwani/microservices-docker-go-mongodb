// Test generated by RoostGPT for test go-roost-remote using AI Type Azure Open AI and AI Model roost-gpt4-32k

/*
1. Scenario: Test that the function correctly deletes an entry in the MongoDB collection when provided a valid id
  - Give the Delete function a valid id
  - Expect it to return delete count 1 and no error

2. Scenario: Test that the function correctly handles an invalid id argument
  - Give the Delete function an invalid id
  - Expect it to return nil and an error return

3. Scenario: Test the behaviour when the provided id does not exist in the database
  - Give the Delete function a valid but non-existing id
  - Expect it to return delete count 0 and no error, as MongoDB's delete method does not return an error in such cases

4. Scenario: Test the behavior with an empty string id
  - Give the Delete function an empty string id
  - Expect it to return nil and throw a parsing error due to invalid ObjectID

5. Scenario: Test the function's behavior in case of a MongoDB connection issue
  - Set up the test to simulate a MongoDB connection issue
  - Give the Delete function a valid id
  - Expect it to return nil and mongodb's own connection error

6. Scenario: Test the function's behavior when the MongoDB database is locked or unavailable
  - Set up the test to simulate the MongoDB locked situation
  - Give the Delete function a valid ID
  - Expect it to return nil and throw a MongoDB's own operation error

7. Scenario: Test the function's behavior when the MongoDB collection is empty.
  - Clear the MongoDB collection before the test
  - Give the Delete function a valid ID
  - Expect it to return delete count 0 and no error, as Mongo DB's delete function does not return an error when no document was deleted.
*/
package mongodb

import (
	"context"
	"errors"
	"testing"

	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"

	"github.com/stretchr/testify/mock"
)

// Mock MongoDB collection
type MockMongoCollection struct {
	mock.Mock
}

func (m *MockMongoCollection) DeleteOne(ctx context.Context, filter interface{},
	opts ...*options.DeleteOptions) (*mongo.DeleteResult, error) {

	args := m.Called(ctx, filter)
	return args.Get(0).(*mongo.DeleteResult), args.Error(1)
}

func TestDelete_2b7afa0d05(t *testing.T) {
	tests := []struct {
		name           string
		id             string
		mockReturn     *mongo.DeleteResult
		mockError      error
		expectedResult *mongo.DeleteResult
		expectedError  error
	}{
		{
			name:           "Valid ID",
			id:             primitive.NewObjectID().Hex(),
			mockReturn:     &mongo.DeleteResult{DeletedCount: 1},
			expectedResult: &mongo.DeleteResult{DeletedCount: 1},
		},
		{
			name:           "Invalid ID",
			id:             "not-an-id",
			expectedResult: nil,
			expectedError:  primitive.ErrInvalidHex,
		},
		{
			name:           "Non-existing ID",
			id:             primitive.NewObjectID().Hex(),
			mockReturn:     &mongo.DeleteResult{DeletedCount: 0},
			expectedResult: &mongo.DeleteResult{DeletedCount: 0},
		},
		{
			name:           "Empty String ID",
			id:             "",
			expectedResult: nil,
			expectedError:  primitive.ErrInvalidHex,
		},
		{
			name:           "MongoDB Connection Issue",
			id:             primitive.NewObjectID().Hex(),
			mockError:      errors.New("Failed to connect to MongoDB"),
			expectedResult: nil,
			expectedError:  errors.New("Failed to connect to MongoDB"),
		},
		{
			name:           "MongoDB Collection Locked",
			id:             primitive.NewObjectID().Hex(),
			mockError:      mongo.ErrOperation,
			expectedResult: nil,
			expectedError:  mongo.ErrOperation,
		},
		{
			name:           "MongoDB Collection Empty",
			id:             primitive.NewObjectID().Hex(),
			mockReturn:     &mongo.DeleteResult{DeletedCount: 0},
			expectedResult: &mongo.DeleteResult{DeletedCount: 0},
		},
	}

	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			mc := new(MockMongoCollection)
			mc.On("DeleteOne", context.TODO(),
				primitive.M{PrimitiveIDFieldNAME: p}).Return(test.mockReturn, test.mockError)

			m := &BookingModel{C: mc}

			output, err := m.Delete(test.id)

			// Validation
			if output != test.expectedResult {
				t.Errorf("Delete(%v) = %v, want %v", test.id, output, test.expectedResult)
			}
			if err != test.expectedError {
				t.Errorf("Delete(%v) returned error: %v, want %v", test.id, err, test.expectedError)
			}
		})
	}
}
