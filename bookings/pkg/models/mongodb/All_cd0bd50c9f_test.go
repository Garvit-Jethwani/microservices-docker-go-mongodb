// Test generated by RoostGPT for test go-mcvs using AI Type Azure Open AI and AI Model roost-gpt4-32k

/*
1. Test scenario: Collection has no booking documents
  - Description:
  - The function is called when the Mongo collection contains no booking documents.
  - Expected result:
  - An empty array is returned with no errors.

2. Test scenario: Collection has one booking document
  - Description:
  - The function is called when the Mongo collection contains a single booking document.
  - Expected result:
  - An array containing that single booking document is returned with no errors.

3. Test scenario: Collection has multiple booking documents
  - Description:
  - The function is called when the Mongo collection contains multiple booking documents.
  - Expected result:
  - An array containing all the booking documents in the collection is returned with no errors.

4. Test scenario: Incorrect collection schema
  - Description:
  - The function is called and the collection schema does not match with the booking schema.
  - Expected result:
  - It should return an error.

5. Test scenario: Find command fails due to some internal error in MongoDB
  - Description:
  - The function is called but the Find method on the Mongo collection returns an error.
  - Expected result:
  - That error should be returned by the function.

6. Test scenario: Collection operation takes too long
  - Description:
  - The function is called but the Find or All operations take too long to complete and there is a context deadline.
  - Expected result:
  - The function should return a context deadline exceeded error.

7. Test scenario: The function is called with null collection
  - Description:
  - The function is called with a null reference to the Mongo collection.
  - Expected result:
  - It should return an error indicating that the collection reference cannot be null.
*/
package mongodb

import (
	"context"
	"errors"
	"testing"
	"time"

	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"

	"github.com/mmorejon/microservices-docker-go-mongodb/bookings/pkg/models"
	"github.com/stretchr/testify/assert"
)

// mockMongoCollection for mocking mongodb collection
type mockMongoCollection struct {
	mongo.Collection
	findError error
	data      []models.Booking
}

// Find method for mock collection
func (m *mockMongoCollection) Find(ctx context.Context, filter interface{}, opts ...*options.FindOptions) (*mongo.Cursor, error) {
	if m.findError != nil {
		return nil, m.findError
	}

	cursor := &mongo.Cursor{}
	// Mocking mongo cursor's behaviour
	cursor.All = func(ctx context.Context, results interface{}) error {
		res, ok := results.(*[]models.Booking)
		if !ok {
			return errors.New("invalid schema")
		}
		*res = m.data
		return nil
	}
	return cursor, nil
}

// TestAll_cd0bd50c9f for testing All method of BookingModel in different situations.
func TestAll_cd0bd50c9f(t *testing.T) {
	booking1 := models.Booking{ID: createObjectID(), UserID: "u1", ShowtimeID: "s1", Movies: []string{"m1"}}
	booking2 := models.Booking{ID: createObjectID(), UserID: "u2", ShowtimeID: "s2", Movies: []string{"m2"}}

	tests := []struct {
		name    string
		coll    *BookingModel
		want    []models.Booking
		wantErr error
	}{
		{
			name:    "Test scenario: Collection has no booking documents",
			coll:    &BookingModel{C: &mockMongoCollection{data: []models.Booking{}}},
			want:    []models.Booking{},
			wantErr: nil,
		},
		{
			name:    "Test scenario: Collection has one booking document",
			coll:    &BookingModel{C: &mockMongoCollection{data: []models.Booking{booking1}}},
			want:    []models.Booking{booking1},
			wantErr: nil,
		},
		{
			name:    "Test scenario: Collection has multiple booking documents",
			coll:    &BookingModel{C: &mockMongoCollection{data: []models.Booking{booking1, booking2}}},
			want:    []models.Booking{booking1, booking2},
			wantErr: nil,
		},
		{
			name:    "Test scenario: Incorrect collection schema",
			coll:    &BookingModel{C: &mockMongoCollection{findError: errors.New("invalid schema")}},
			want:    nil,
			wantErr: errors.New("invalid schema"),
		},
		{
			name:    "Test scenario: Find command fails due to some internal error in MongoDB",
			coll:    &BookingModel{C: &mockMongoCollection{findError: errors.New("find command failed")}},
			want:    nil,
			wantErr: errors.New("find command failed"),
		},
		{
			name:    "Test scenario: Collection operation takes too long",
			coll:    &BookingModel{C: &mockMongoCollection{}},
			want:    nil,
			wantErr: context.DeadlineExceeded,
		},
		{
			name:    "Test scenario: The function is called with null collection",
			coll:    &BookingModel{C: nil},
			want:    nil,
			wantErr: errors.New("collection can't be null"),
		},
	}
	ctx, cancel := context.WithDeadline(context.Background(), time.Now())
	defer cancel()

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := tt.coll.All()
			if err != nil {
				assert.Error(t, err, tt.wantErr.Error())
			} else {
				assert.ElementsMatch(t, got, tt.want)
			}
		})
	}
}

func createObjectID() primitive.ObjectID {
	id, _ := primitive.ObjectIDFromHex("60b4df3f8aed21fef68f697b")
	return id
}
