// Test generated by RoostGPT for test go-roost-remote using AI Type Azure Open AI and AI Model roost-gpt4-32k

/*
Test Scenarios:

1. Success Scenario: Test to ensure the "All" function is able to return all booking records in the correct structure as modeled in "models.Booking" when the database connection and retrieval operations are successful.

2. No Records Available: Test to ensure the function returns an empty list when there are no booking records in the collection.

3. Database Connection Failure: Test the function's return value and error handling when there's a failure connecting to the Mongo DB collection, such as a network issue or invalid connection details.

4. Cursor Error: Verify the function's behaviour and error handling when an error occurs while creating the cursor for the 'Find' operation, for example, when there is an invalid query.

5. Data Retrieval Error: Test the function's behaviour when there's an error retrieving data from the 'Find' operation or during the conversion to the "models.Booking" structure.

6. Context Cancellation: Test how the function behaves when the context used for database operations is cancelled before the function completes.

7. Context Deadline Exceeded: Test the function's response when the context deadline has been exceeded

8. Error Handling: Ensure any errors returned by the database commands are correctly wrapped and returned to the caller function.

9. Invalid Data Structure in Collection: Test the function's response when the data in the collection does not conform to the "models.Booking" structure.

10. Concurrent Access: Test the function's performance and correctness when accessed concurrently, it should handle multiple requests concurrently and shouldn't affect the data integrity.
*/
package mongodb

import (
	"context"
	"errors"
	"testing"
	"time"

	"github.com/mmorejon/microservices-docker-go-mongodb/bookings/pkg/models"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
)

type MockMongoCursor struct {
	mock.Mock
}

func (m *MockMongoCursor) All(ctx context.Context, results interface{}) error {
	args := m.Called(ctx, results)
	return args.Error(0)
}

type MockMongoCollection struct {
	mock.Mock
}

func (m *MockMongoCollection) Find(ctx context.Context, filter interface{}) (*MockMongoCursor, error) {
	args := m.Called(ctx, filter)
	return args.Get(0).(*MockMongoCursor), args.Error(1)
}

func TestAll_cd0bd50c9f(t *testing.T) {
	b := []models.Booking{{ID: primitive.ObjectID{}, Date: time.Now()}}
	ctx := context.TODO()
	bookingC := new(MockMongoCollection)
	bookingCur := new(MockMongoCursor)
	bookingM := BookingModel{C: bookingC}

	tests := []struct {
		name              string
		returnCursorError error
		findAllError      error
		expectedrecord    []models.Booking
		expectedError     error
	}{
		{"success", nil, nil, b, nil},
		{"failure_find", errors.New("find error"), nil, nil, errors.New("find error")},
		{"failure_all", nil, errors.New("All error"), nil, errors.New("All error")},
	}

	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			bookingC.On("Find", ctx, bson.M{}).Return(bookingCur, test.returnCursorError)
			bookingCur.On("All", ctx, mock.Anything).Return(test.findAllError)

			records, err := bookingM.All()

			assert.Equal(t, test.expectedrecord, records)
			assert.Equal(t, test.expectedError, err)

			bookingC.AssertExpectations(t)
			bookingCur.AssertExpectations(t)
		})
	}
}
